#version 450 core
#extension GL_ARB_bindless_texture : require

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba16f, binding = 0) uniform image3D u_VPLGrid_Albedo;
layout(rgba16f, binding = 1) uniform image3D u_VPLGrid_Direction;

struct VPL {
    vec3  position;
    uint  packedColor;
    uint  packedNormal;
    uvec2 shadowMapHandle;
};

layout(std430, binding = 4) readonly buffer VPLBlock {
    VPL vpls[];
};

uniform int num_vpls;
uniform ivec3 u_gridResolution;
uniform vec3 u_gridMin;
uniform vec3 u_gridMax;
uniform float u_bias;

const float PI = 3.14159265359;

float calculateVPLShadow(uvec2 shadowMapHandleUvec2, vec3 worldPos, VPL vpl)
{
    if (shadowMapHandleUvec2.x == 0u && shadowMapHandleUvec2.y == 0u) {
        return 1.0; 
    }
    samplerCube shadowSampler = samplerCube(shadowMapHandleUvec2);
    
    vec3 fragToLight = worldPos - vpl.position;
    float currentDepth = length(fragToLight);
    float farPlane = 100.0;
    
    if(currentDepth > farPlane) {
        return 0.0;
    }

    vec3 vplNormal = unpackSnorm4x8(vpl.packedNormal).xyz;

    vec3 lightDir = normalize(vpl.position - worldPos);

    float bias = max(u_bias * (1.0 - dot(vplNormal, lightDir)), 0.005);
    
    float closestDepth = texture(shadowSampler, fragToLight).r;
    closestDepth *= farPlane; 
    
    return currentDepth > closestDepth + bias ? 0.0 : 1.0;
}

void main() {
    ivec3 voxel_coord = ivec3(gl_GlobalInvocationID.xyz);
    if (voxel_coord.x >= u_gridResolution.x || voxel_coord.y >= u_gridResolution.y || voxel_coord.z >= u_gridResolution.z) {
        return;
    }

    vec3 grid_size = u_gridMax - u_gridMin;
    vec3 world_pos = u_gridMin + (vec3(voxel_coord) + 0.5) / vec3(u_gridResolution) * grid_size;

    vec3 accumulatedLight = vec3(0.0);
    vec3 accumulatedDirection = vec3(0.0);

    for (int i = 0; i < num_vpls; ++i)
    {
        VPL currentVPL = vpls[i];
        if (currentVPL.packedColor == 0u) continue;

        float shadow = calculateVPLShadow(currentVPL.shadowMapHandle, world_pos, currentVPL);
        
        if (shadow > 0.0) 
        {
            vec3 vplToFrag = world_pos - currentVPL.position;
            float distSq = dot(vplToFrag, vplToFrag);
            distSq = max(distSq, 0.000001);

            vec4 vpl_color_unpacked = unpackUnorm4x8(currentVPL.packedColor);
            vec3 vpl_color_rgb = vpl_color_unpacked.rgb;

            float attenuation = 1.0 / (distSq + 1.0);

            vec3 vplNormal = unpackSnorm4x8(currentVPL.packedNormal).xyz;
            float NdotL = max(dot(vplNormal, normalize(vplToFrag)), 0.0);

            vec3 lightContribution = vpl_color_rgb * attenuation * shadow * NdotL;
            accumulatedLight += lightContribution;
            accumulatedDirection += normalize(vplToFrag) * length(lightContribution);
        }
    }

    if (length(accumulatedDirection) > 0.0) {
        accumulatedDirection = normalize(accumulatedDirection);
    }

    imageStore(u_VPLGrid_Albedo, voxel_coord, vec4(accumulatedLight, 1.0));
    imageStore(u_VPLGrid_Direction, voxel_coord, vec4(accumulatedDirection, 1.0));
}