#version 450 core
#extension GL_ARB_bindless_texture : require

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba16f, binding = 0) uniform image3D u_VPLGrid;

struct VPL {
    vec3  position;
    uint  packedColor;
    uint  packedNormal;
    uvec2 shadowMapHandle;
};

layout(std430, binding = 4) readonly buffer VPLBlock {
    VPL vpls[];
};

uniform int num_vpls;
uniform ivec3 u_gridResolution;
uniform vec3 u_gridMin;
uniform vec3 u_gridMax;

const float PI = 3.14159265359;

float calculateVPLShadow(uvec2 shadowMapHandleUvec2, vec3 fragPos, vec3 lightPos)
{
    if (shadowMapHandleUvec2.x == 0u && shadowMapHandleUvec2.y == 0u) {
        return 1.0; 
    }
    samplerCube shadowSampler = samplerCube(shadowMapHandleUvec2);
    
    vec3 fragToLight = fragPos - lightPos;
    float currentDepth = length(fragToLight);
    float farPlane = 25.0;
    if(currentDepth > farPlane) {
        return 0.0;
    }

    float closestDepth = texture(shadowSampler, fragToLight).r;
    closestDepth *= farPlane;

    float bias = 0.1;
    return currentDepth > closestDepth + bias ? 0.0 : 1.0;
}

void main() {
    ivec3 voxel_coord = ivec3(gl_GlobalInvocationID.xyz);
    if (voxel_coord.x >= u_gridResolution.x || voxel_coord.y >= u_gridResolution.y || voxel_coord.z >= u_gridResolution.z) {
        return;
    }

    vec3 grid_size = u_gridMax - u_gridMin;
    vec3 world_pos = u_gridMin + (vec3(voxel_coord) + 0.5) / vec3(u_gridResolution) * grid_size;

    vec3 accumulatedLight = vec3(0.0);

    for (int i = 0; i < num_vpls; ++i)
    {
        vec3 vpl_pos = vpls[i].position;
        if (vpls[i].packedColor == 0u) continue;

        float shadow = calculateVPLShadow(vpls[i].shadowMapHandle, world_pos, vpl_pos);
        if (shadow > 0.0) 
        {
            vec3 vplToFrag = world_pos - vpl_pos;
            float distSq = dot(vplToFrag, vplToFrag);
            distSq = max(distSq, 0.000001);

            vec4 vpl_color_unpacked = unpackUnorm4x8(vpls[i].packedColor);
            vec3 vpl_color_rgb = vpl_color_unpacked.rgb;

            float attenuation = 1.0 / (distSq + 1.0);

            accumulatedLight += vpl_color_rgb * attenuation * shadow;
        }
    }

    imageStore(u_VPLGrid, voxel_coord, vec4(accumulatedLight, 1.0));
}