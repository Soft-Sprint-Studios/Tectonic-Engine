#version 460 core
layout(triangles, equal_spacing, ccw) in;

in TCS_OUT {
    vec3 worldPos;
    vec2 texCoords;
    vec3 normal;
} tes_in[];

out TES_OUT {
    vec3 WorldPos;
    vec3 Normal;
    vec2 TexCoords;
    vec4 FragPosSunLightSpace;
} tes_out;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 sunLightSpaceMatrix;
uniform float time;

const int NUM_WAVES = 4;
vec2 wave_dirs[NUM_WAVES] = vec2[](
    vec2(1.0, 0.3),
    vec2(0.7, 0.8),
    vec2(-0.2, 0.9),
    vec2(-0.8, -0.4)
);
float wave_amps[NUM_WAVES] = float[](0.02, 0.01, 0.01, 0.02);
float wave_freqs[NUM_WAVES] = float[](12.0, 20.0, 8.0, 26.0);
float wave_speeds[NUM_WAVES] = float[](0.5, 0.3, 1.0, 0.4);

vec3 gerstner_wave(vec2 xz) {
    vec3 p = vec3(0.0);
    for (int i=0; i < NUM_WAVES; i++) {
        float steepness = 0.8 / (wave_freqs[i] * wave_amps[i] * NUM_WAVES);
        float k = wave_freqs[i];
        float c = sqrt(9.8 / k);
        vec2 d = normalize(wave_dirs[i]);
        float f = k * (dot(d, xz) - c * time * wave_speeds[i]);
        float a = wave_amps[i];

        p.x += steepness * a * d.x * cos(f);
        p.y += a * sin(f);
        p.z += steepness * a * d.y * cos(f);
    }
    return p;
}

vec3 gerstner_normal(vec2 xz) {
    vec3 n = vec3(0.0);
    for(int i=0; i<NUM_WAVES; i++) {
        float steepness = 0.8 / (wave_freqs[i] * wave_amps[i] * NUM_WAVES);
        float k = wave_freqs[i];
        float c = sqrt(9.8 / k);
        vec2 d = normalize(wave_dirs[i]);
        float f = k * (dot(d, xz) - c * time * wave_speeds[i]);
        float a = wave_amps[i];

        n.x += d.x * k * a * cos(f);
        n.z += d.y * k * a * cos(f);
        n.y += steepness * k * a * sin(f);
    }
    return normalize(vec3(-n.x, 1.0 - n.y, -n.z));
}

void main()
{
    vec3 p0 = gl_TessCoord.x * tes_in[0].worldPos;
    vec3 p1 = gl_TessCoord.y * tes_in[1].worldPos;
    vec3 p2 = gl_TessCoord.z * tes_in[2].worldPos;
    vec3 worldPos_interp = p0 + p1 + p2;
    
    vec2 tex0 = gl_TessCoord.x * tes_in[0].texCoords;
    vec2 tex1 = gl_TessCoord.y * tes_in[1].texCoords;
    vec2 tex2 = gl_TessCoord.z * tes_in[2].texCoords;
    tes_out.TexCoords = tex0 + tex1 + tex2;

    vec3 displacement = gerstner_wave(worldPos_interp.xz);
    vec3 finalWorldPos = worldPos_interp + displacement;
    
    tes_out.WorldPos = finalWorldPos;
    tes_out.Normal = gerstner_normal(worldPos_interp.xz);
    tes_out.FragPosSunLightSpace = sunLightSpaceMatrix * vec4(finalWorldPos, 1.0);
    
    gl_Position = projection * view * vec4(finalWorldPos, 1.0);
}