#version 460 core
layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct VPL {
    vec3 position;
    uint packedColor;
    uint packedNormal;
    uvec2 shadowMapHandle;
};

layout(std430, binding = 4) buffer VPLBlock {
    VPL vpls[];
};

uniform sampler2D u_posTex;
uniform sampler2D u_normalTex;
uniform sampler2D u_albedoTex;

uniform int u_vpl_offset;
uniform int u_vpls_to_generate;

uniform vec3 u_lightPos;
uniform vec3 u_lightColor;
uniform float u_lightIntensity;

const float PI = 3.14159265359;

float halton(uint i, uint b) {
    float f = 1.0;
    float r = 0.0;
    while (i > 0) {
        f = f / float(b);
        r = r + f * (i % b);
        i = i / b;
    }
    return r;
}

void main() {
    uint index = gl_GlobalInvocationID.x;
	
	if (index >= u_vpls_to_generate) {
        return;
    }
	
    uint total_index = index + u_vpl_offset;
    if (total_index >= vpls.length()) return;

    ivec2 tex_size = textureSize(u_posTex, 0);
    vec2 random_uv = vec2(halton(index, 2), halton(index, 3));
    ivec2 random_coords = ivec2(random_uv * tex_size);

    vec4 pos_data = texelFetch(u_posTex, random_coords, 0);
    vec3 vpl_pos = pos_data.xyz;

    if (pos_data.w == 0.0) {
        vpls[total_index].packedColor = 0u;
        vpls[total_index].packedNormal = 0u;
        vpls[total_index].position = vec3(0.0);
        return;
    }

    vec3 normal = normalize(texelFetch(u_normalTex, random_coords, 0).xyz);
    vec3 albedo = texelFetch(u_albedoTex, random_coords, 0).rgb;

    float dist_sq = dot(u_lightPos - vpl_pos, u_lightPos - vpl_pos);
    float attenuation = 1.0 / (dist_sq + 1.0);

    vec3 vpl_energy = u_lightColor * u_lightIntensity * albedo / PI;

    uint packed_color = packUnorm4x8(vec4(vpl_energy * attenuation, 1.0));

    uint packed_normal = packSnorm4x8(vec4(normal, 0.0));

    vpls[total_index].position = vpl_pos + normal * 0.001;
    vpls[total_index].packedColor = packed_color;
    vpls[total_index].packedNormal = packed_normal;
}