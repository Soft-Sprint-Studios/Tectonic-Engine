#version 450 core
#extension GL_ARB_bindless_texture : require

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct ShaderLight {
    vec4 position;
    vec4 direction;
    vec4 color;
    vec4 params1;
    vec4 params2;
    uvec2 shadowMapHandle;
    uvec2 cookieMapHandle;
};

layout(std430, binding = 3) readonly buffer LightBlock {
    ShaderLight lights[];
};

layout(std430, binding = 5) buffer LightGrid {
    uvec2 light_grid[];
};

layout(std430, binding = 6) buffer LightIndexList {
    uint light_index_list[];
};

layout(std430, binding = 7) buffer GlobalLightCounter {
    uint next_light_index;
};

uniform mat4 invProjection;
uniform mat4 view;
uniform vec2 screenSize;
uniform int numActiveLights;
uniform sampler2D gPosition;

#define TILE_SIZE_X 16
#define TILE_SIZE_Y 16

shared uint shared_light_indices[1024];
shared uint local_light_count;
shared uint local_base_index;

vec3 screenToView(vec4 screenPos) {
    vec2 texCoord = screenPos.xy / screenSize;
    vec4 clip = vec4(vec2(texCoord.x, 1.0 - texCoord.y) * 2.0 - 1.0, screenPos.z, 1.0);
    vec4 viewPos = invProjection * clip;
    return viewPos.xyz / viewPos.w;
}

void main() {
    if (gl_LocalInvocationIndex == 0) {
        local_light_count = 0;
    }
    barrier();

    ivec2 tileID = ivec2(gl_WorkGroupID.xy);
    uint tile_index = tileID.y * uint(gl_NumWorkGroups.x) + tileID.x;

    vec3 frustum_planes[4];
    vec2 tile_min_uv = vec2(tileID * uvec2(TILE_SIZE_X, TILE_SIZE_Y)) / screenSize;
    vec2 tile_max_uv = vec2((tileID + 1) * uvec2(TILE_SIZE_X, TILE_SIZE_Y)) / screenSize;
    
    vec3 v0 = screenToView(vec4(tile_min_uv * screenSize, 1.0, 1.0));
    vec3 v1 = screenToView(vec4(vec2(tile_max_uv.x, tile_min_uv.y) * screenSize, 1.0, 1.0));
    vec3 v2 = screenToView(vec4(vec2(tile_min_uv.x, tile_max_uv.y) * screenSize, 1.0, 1.0));
    vec3 v3 = screenToView(vec4(tile_max_uv * screenSize, 1.0, 1.0));

    frustum_planes[0] = normalize(cross(v0, v2));
    frustum_planes[1] = normalize(cross(v3, v1));
    frustum_planes[2] = normalize(cross(v2, v3));
    frustum_planes[3] = normalize(cross(v1, v0));

    for (uint i = gl_LocalInvocationIndex; i < numActiveLights; i += gl_WorkGroupSize.x) {
        ShaderLight light = lights[i];
        vec3 light_pos_view = (view * vec4(light.position.xyz, 1.0)).xyz;
        float light_radius = light.params1.x;

        bool in_frustum = true;
        for (int p = 0; p < 4; ++p) {
            if (dot(frustum_planes[p], light_pos_view) < -light_radius) {
                in_frustum = false;
                break;
            }
        }
        
        if (in_frustum) {
            uint index = atomicAdd(local_light_count, 1);
            if (index < 1024) {
                shared_light_indices[index] = i;
            }
        }
    }

    barrier();

    if (gl_LocalInvocationIndex == 0) {
        if (local_light_count > 0) {
            local_base_index = atomicAdd(next_light_index, local_light_count);
            light_grid[tile_index] = uvec2(local_base_index, local_light_count);
        } else {
            light_grid[tile_index] = uvec2(0, 0);
        }
    }
    
    barrier();

    for (uint i = gl_LocalInvocationIndex; i < local_light_count; i += gl_WorkGroupSize.x) {
        light_index_list[local_base_index + i] = shared_light_indices[i];
    }
}