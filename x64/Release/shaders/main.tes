#version 450 core
layout(triangles, equal_spacing, ccw) in;

in TCS_OUT {
    vec3 worldPos;
    vec2 texCoords;
    vec2 texCoords2;
    vec2 texCoords3;
    vec2 texCoords4;
	vec2 lightmapTexCoords;
    vec3 worldNormal;
    mat3 tbn;
    vec4 color;
	vec4 color2;
	ivec4 boneIndices;
    vec4 boneWeights;
    flat int isBrush;
} tes_in[];

out vec3 FragPos_view;
out vec3 Normal_view;
out vec3 FragPos_world;
out vec2 TexCoords;
out vec2 TexCoords2;
out vec2 TexCoords3;
out vec2 TexCoords4;
out vec2 TexCoordsLightmap;
out mat3 TBN;
out vec4 FragPosSunLightSpace;
out vec2 Velocity;
out vec4 v_Color;
out vec4 v_Color2;
out float fadeAlpha;
flat out int isBrush;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 prevViewProjection;
uniform mat4 sunLightSpaceMatrix;
uniform vec3 viewPos;
uniform mat4 model;

uniform float u_fadeStartDist;
uniform float u_fadeEndDist;

void main()
{
    vec3 p0_ws = gl_TessCoord.x * tes_in[0].worldPos;
    vec3 p1_ws = gl_TessCoord.y * tes_in[1].worldPos;
    vec3 p2_ws = gl_TessCoord.z * tes_in[2].worldPos;
    FragPos_world = p0_ws + p1_ws + p2_ws;

    vec2 tc0 = gl_TessCoord.x * tes_in[0].texCoords;
    vec2 tc1 = gl_TessCoord.y * tes_in[1].texCoords;
    vec2 tc2 = gl_TessCoord.z * tes_in[2].texCoords;
    TexCoords = tc0 + tc1 + tc2;

    vec2 tc0_2 = gl_TessCoord.x * tes_in[0].texCoords2;
    vec2 tc1_2 = gl_TessCoord.y * tes_in[1].texCoords2;
    vec2 tc2_2 = gl_TessCoord.z * tes_in[2].texCoords2;
    TexCoords2 = tc0_2 + tc1_2 + tc2_2;

    vec2 tc0_3 = gl_TessCoord.x * tes_in[0].texCoords3;
    vec2 tc1_3 = gl_TessCoord.y * tes_in[1].texCoords3;
    vec2 tc2_3 = gl_TessCoord.z * tes_in[2].texCoords3;
    TexCoords3 = tc0_3 + tc1_3 + tc2_3;
    
    vec2 tc0_4 = gl_TessCoord.x * tes_in[0].texCoords4;
    vec2 tc1_4 = gl_TessCoord.y * tes_in[1].texCoords4;
    vec2 tc2_4 = gl_TessCoord.z * tes_in[2].texCoords4;
    TexCoords4 = tc0_4 + tc1_4 + tc2_4;

    vec4 c0 = gl_TessCoord.x * tes_in[0].color;
    vec4 c1 = gl_TessCoord.y * tes_in[1].color;
    vec4 c2 = gl_TessCoord.z * tes_in[2].color;
    v_Color = c0 + c1 + c2;

	vec4 c0_2 = gl_TessCoord.x * tes_in[0].color2;
    vec4 c1_2 = gl_TessCoord.y * tes_in[1].color2;
    vec4 c2_2 = gl_TessCoord.z * tes_in[2].color2;
    v_Color2 = c0_2 + c1_2 + c2_2;
	
	vec2 lm_tc0 = gl_TessCoord.x * tes_in[0].lightmapTexCoords;
    vec2 lm_tc1 = gl_TessCoord.y * tes_in[1].lightmapTexCoords;
    vec2 lm_tc2 = gl_TessCoord.z * tes_in[2].lightmapTexCoords;
    TexCoordsLightmap = lm_tc0 + lm_tc1 + lm_tc2;
	
    isBrush = tes_in[0].isBrush;
	
    if (u_fadeEndDist > 0.0) {
        float dist = length(FragPos_world - viewPos);
        fadeAlpha = 1.0 - smoothstep(u_fadeStartDist, u_fadeEndDist, dist);
    } else {
        fadeAlpha = 1.0;
    }
    
    vec3 worldNormal;
    if (tes_in[0].isBrush == 1)
    {
        vec3 edge1 = tes_in[1].worldPos - tes_in[0].worldPos;
        vec3 edge2 = tes_in[2].worldPos - tes_in[0].worldPos;
        worldNormal = normalize(cross(edge1, edge2));
        vec2 duv1 = tes_in[1].texCoords - tes_in[0].texCoords;
        vec2 duv2 = tes_in[2].texCoords - tes_in[0].texCoords;
        float r = 1.0f / (duv1.x * duv2.y - duv1.y * duv2.x);
        vec3 tangent_calc = (edge1 * duv2.y - edge2 * duv1.y) * r;
        vec3 bitangent_calc = (edge2 * duv1.x - edge1 * duv2.x) * r;
        float handedness = (dot(cross(worldNormal, tangent_calc), bitangent_calc) < 0.0) ? -1.0 : 1.0;
        vec3 tangent = normalize(tangent_calc);
        vec3 bitangent = normalize(cross(worldNormal, tangent)) * handedness;
        TBN = mat3(tangent, bitangent, worldNormal);
    }
    else
    {
        vec3 n0 = gl_TessCoord.x * tes_in[0].worldNormal;
        vec3 n1 = gl_TessCoord.y * tes_in[1].worldNormal;
        vec3 n2 = gl_TessCoord.z * tes_in[2].worldNormal;
        worldNormal = normalize(n0 + n1 + n2);
        
        mat3 tbn0 = gl_TessCoord.x * tes_in[0].tbn;
        mat3 tbn1 = gl_TessCoord.y * tes_in[1].tbn;
        mat3 tbn2 = gl_TessCoord.z * tes_in[2].tbn;
        TBN = tbn0 + tbn1 + tbn2;
    }

    FragPos_view = vec3(view * vec4(FragPos_world, 1.0));
    Normal_view = mat3(transpose(inverse(view * model))) * worldNormal;
    FragPosSunLightSpace = sunLightSpaceMatrix * vec4(FragPos_world, 1.0);
    gl_Position = projection * view * vec4(FragPos_world, 1.0);
    vec4 prevClipPos = prevViewProjection * vec4(FragPos_world, 1.0);
    vec2 prevNDC = prevClipPos.xy / prevClipPos.w;
    vec2 currentNDC = gl_Position.xy / gl_Position.w;
    Velocity = currentNDC - prevNDC;
}