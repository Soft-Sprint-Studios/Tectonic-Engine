#version 450 core
#extension GL_ARB_bindless_texture : enable
layout(triangles, equal_spacing, ccw) in;

in TCS_OUT {
    vec3 worldPos;
    vec2 texCoords;
    vec2 texCoords2;
    vec2 texCoords3;
    vec2 texCoords4;
    vec3 worldNormal;
    mat3 tbn;
    vec4 color;
    flat int isBrush;
} tes_in[];

out vec3 FragPos_view;
out vec3 Normal_view;
out vec3 FragPos_world;
out vec2 TexCoords;
out vec2 TexCoords2;
out vec2 TexCoords3;
out vec2 TexCoords4;
out mat3 TBN;
out vec4 FragPosSunLightSpace;
out vec2 Velocity;
out vec3 TangentViewPos;
out vec3 TangentFragPos;
out vec4 v_Color;
out float fadeAlpha;
out vec3 indirectLight;

uniform mat4 view;
uniform mat4 projection;
uniform mat4 prevViewProjection;
uniform mat4 sunLightSpaceMatrix;
uniform vec3 viewPos;
uniform mat4 model;

uniform float u_fadeStartDist;
uniform float u_fadeEndDist;

struct VPL {
    vec3  position;
    uint  packedColor;
    uint  packedNormal;
    uvec2 shadowMapHandle;
};

layout(std430, binding = 4) readonly buffer VPLBlock {
    VPL vpls[];
};
uniform int num_vpls;
const float PI = 3.14159265359;

float calculateVPLShadow(uvec2 shadowMapHandleUvec2, vec3 fragPos, vec3 lightPos)
{
    if (shadowMapHandleUvec2.x == 0u && shadowMapHandleUvec2.y == 0u) {
        return 1.0; 
    }
    samplerCube shadowSampler = samplerCube(shadowMapHandleUvec2);
    
    vec3 fragToLight = fragPos - lightPos;
    float currentDepth = length(fragToLight);

    float farPlane = 25.0;
    if(currentDepth > farPlane) {
        return 0.0;
    }

    float closestDepth = texture(shadowSampler, fragToLight).r;
    closestDepth *= farPlane; 
    
    float bias = 0.05;
    return currentDepth > closestDepth + bias ? 0.0 : 1.0;
}

void main()
{
    vec3 p0_ws = gl_TessCoord.x * tes_in[0].worldPos;
    vec3 p1_ws = gl_TessCoord.y * tes_in[1].worldPos;
    vec3 p2_ws = gl_TessCoord.z * tes_in[2].worldPos;
    FragPos_world = p0_ws + p1_ws + p2_ws;

    vec2 tc0 = gl_TessCoord.x * tes_in[0].texCoords;
    vec2 tc1 = gl_TessCoord.y * tes_in[1].texCoords;
    vec2 tc2 = gl_TessCoord.z * tes_in[2].texCoords;
    TexCoords = tc0 + tc1 + tc2;

    vec2 tc0_2 = gl_TessCoord.x * tes_in[0].texCoords2;
    vec2 tc1_2 = gl_TessCoord.y * tes_in[1].texCoords2;
    vec2 tc2_2 = gl_TessCoord.z * tes_in[2].texCoords2;
    TexCoords2 = tc0_2 + tc1_2 + tc2_2;

    vec2 tc0_3 = gl_TessCoord.x * tes_in[0].texCoords3;
    vec2 tc1_3 = gl_TessCoord.y * tes_in[1].texCoords3;
    vec2 tc2_3 = gl_TessCoord.z * tes_in[2].texCoords3;
    TexCoords3 = tc0_3 + tc1_3 + tc2_3;
    
    vec2 tc0_4 = gl_TessCoord.x * tes_in[0].texCoords4;
    vec2 tc1_4 = gl_TessCoord.y * tes_in[1].texCoords4;
    vec2 tc2_4 = gl_TessCoord.z * tes_in[2].texCoords4;
    TexCoords4 = tc0_4 + tc1_4 + tc2_4;

    vec4 c0 = gl_TessCoord.x * tes_in[0].color;
    vec4 c1 = gl_TessCoord.y * tes_in[1].color;
    vec4 c2 = gl_TessCoord.z * tes_in[2].color;
    v_Color = c0 + c1 + c2;
	
   if (tes_in[0].isBrush == 0 && u_fadeEndDist > 0.0) {
        float dist = length(FragPos_world - viewPos);
        fadeAlpha = 1.0 - smoothstep(u_fadeStartDist, u_fadeEndDist, dist);
    } else {
        fadeAlpha = 1.0;
    }
    
    vec3 worldNormal;
    if (tes_in[0].isBrush == 1)
    {
        vec3 edge1 = tes_in[1].worldPos - tes_in[0].worldPos;
        vec3 edge2 = tes_in[2].worldPos - tes_in[0].worldPos;
        worldNormal = normalize(cross(edge1, edge2));
        vec2 duv1 = tes_in[1].texCoords - tes_in[0].texCoords;
        vec2 duv2 = tes_in[2].texCoords - tes_in[0].texCoords;
        float r = 1.0f / (duv1.x * duv2.y - duv1.y * duv2.x);
        vec3 tangent = normalize((edge1 * duv2.y - edge2 * duv1.y) * r);
        vec3 bitangent = normalize(cross(worldNormal, tangent));
        TBN = mat3(tangent, bitangent, worldNormal);
    }
    else
    {
        vec3 n0 = gl_TessCoord.x * tes_in[0].worldNormal;
        vec3 n1 = gl_TessCoord.y * tes_in[1].worldNormal;
        vec3 n2 = gl_TessCoord.z * tes_in[2].worldNormal;
        worldNormal = normalize(n0 + n1 + n2);
        
        mat3 tbn0 = gl_TessCoord.x * tes_in[0].tbn;
        mat3 tbn1 = gl_TessCoord.y * tes_in[1].tbn;
        mat3 tbn2 = gl_TessCoord.z * tes_in[2].tbn;
        TBN = tbn0 + tbn1 + tbn2;
    }
    
    indirectLight = vec3(0.0);
    for (int i = 0; i < num_vpls; ++i)
    {
        vec3 vpl_pos = vpls[i].position;
        if (vpls[i].packedColor == 0u) continue;

        float shadow = calculateVPLShadow(vpls[i].shadowMapHandle, FragPos_world, vpl_pos);
        if (shadow > 0.0) 
        {
            vec3 vplToFrag = FragPos_world - vpl_pos;
            float distance = length(vplToFrag);
            if (distance < 0.001) distance = 0.001; 

            vec3 L = -normalize(vplToFrag);
            float NdotL = max(dot(worldNormal, L), 0.0);

            if (NdotL > 0.0) 
            {
                vec4 vpl_color_unpacked = unpackUnorm4x8(vpls[i].packedColor);
                vec3 vpl_color_rgb = vpl_color_unpacked.rgb;
                vec3 vpl_normal = unpackSnorm4x8(vpls[i].packedNormal).xyz;

                float attenuation = 1.0 / (distance * distance + 1.0);
                
                float backface_attenuation_factor;
                float gi_brightness_multiplier;

                if (tes_in[0].isBrush == 1) {
                    backface_attenuation_factor = 1.0; 
                    gi_brightness_multiplier = 1.0; 
                } else {
                    float dot_normals = dot(worldNormal, vpl_normal);
                    backface_attenuation_factor = clamp(1.0 + dot_normals, 0.0, 1.0); 
                    gi_brightness_multiplier = 0.4;
                }

                indirectLight += vpl_color_rgb * NdotL * attenuation * backface_attenuation_factor * gi_brightness_multiplier * shadow;
            }
        }
    }

    FragPos_view = vec3(view * vec4(FragPos_world, 1.0));
    Normal_view = mat3(transpose(inverse(view * model))) * worldNormal;
    FragPosSunLightSpace = sunLightSpaceMatrix * vec4(FragPos_world, 1.0);
    TangentViewPos = TBN * viewPos;
    TangentFragPos = TBN * FragPos_world;
    gl_Position = projection * view * vec4(FragPos_world, 1.0);
    vec4 prevClipPos = prevViewProjection * vec4(FragPos_world, 1.0);
    vec2 prevNDC = prevClipPos.xy / prevClipPos.w;
    vec2 currentNDC = gl_Position.xy / gl_Position.w;
    Velocity = currentNDC - prevNDC;
}